# A street address with latitude and longitude
type Address {
  city: String
  latitude: Float
  longitude: Float
  state: String
  staticMap: Image
  street: String
  zip: String
}

# An Altria reporting period with number of reports available
type ReportsPeriod {
  beginAt: DateTime!
  endAt: DateTime!
  totalCount: Int
}

# Time since epoch in seconds
scalar DateTime

# Autogenerated input type of Echo
input EchoInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  message: String!
}

# Autogenerated return type of Echo
type EchoPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  theSameMessage: String!
}

# An image with size variants
type Image {
  lg: String
  md: String
  og: String
  sm: String
  xl: String
  xs: String
}

type Mutation {
  echo(input: EchoInput!): EchoPayload
}

# An object with an ID.
interface Node {
  # ID of the object.
  id: ID!
}

# Information about pagination in a connection.
type PageInfo {
  # When paginating forwards, the cursor to continue.
  endCursor: String

  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: String
}

# A  C-Store POS configuration
type PosConfiguration {
  posIp: String!
  posName: String!
  proxyHost: String
  proxyPort: String
}

# Supported POS names
enum PosName {
  FOO
  BAR
}

type Query {
  # Fetches an object given its ID.
  node(
    # ID of the object.
    id: ID!
  ): Node

  # Fetches a list of objects given a list of IDs.
  nodes(
    # IDs of the objects.
    ids: [ID!]!
  ): [Node]!

  # Return the logged in user
  viewer: Viewer
}

# A report generated by SKU-OPS
type Report implements Node {
  accountNumber: String
  dbId: ID!
  id: ID!
  reportAccount: ReportAccount
  reportAccountStatus: ReportAccountStatus
  status: ReportStatus
  stores: [ReportStore]
  type: ReportAccountType
}

# A reporting account
type ReportAccount implements Node {
  accountNumber: String
  chain: StoreChain
  id: ID!
  status: ReportAccountStatus
  type: ReportAccountType
}

# Possible statuses for a reporting account/report
enum ReportAccountStatus {
  # A reporting account/report in test mode
  TEST

  # A live reporting account/report
  LIVE
}

# Possible types for a reporting account/report
enum ReportAccountType {
  # An reporting account/report
  FOO
}

# The connection type for Report.
type ReportConnection {
  # A list of edges.
  edges: [ReportEdge]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type ReportEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: Report
}

# Possible statuses for a report
enum ReportStatus {
  # The report has been marked ready to submit
  READY_TO_SUBMIT

  # The report has been marked not ready/needs further review
  NOT_READY

  # The report has been submitted
  SUBMITTED
}

# A store in a Report
type ReportStore implements Node {
  id: ID!
  rowCount: [RowCountPerDay]
  status: ReportStoreStatus
  store: Store
}

# Possible statuses for a Store in a given Report
enum ReportStoreStatus {
  # The Store has been marked invalid for some reason
  INVALID

  # The Store has been marked as needing a refetch
  REFETCH

  # The Store has been marked as needing to be resynced
  RESYNC

  # The Store has been as validated successfully
  VALIDATED
}

# Possible roles for a  user
enum Role {
  # A user who is a StoreChain owner
  CSTORE_OWNER

  # A user who is a Store manager
  CSTORE_MANAGER

  # A user who is a  admin (internal user)
  ADMIN
}

# The number of report rows on a given day for a Store
type RowCountPerDay {
  date: DateTime
  status: RowCountStatus
  volume: Int
}

# Possible statuses for a RowCount
enum RowCountStatus {
  # The row count seems fine relative to other days
  OK

  # The row count seems low relative to other days
  TOO_LOW
}

# A  C-Store
type Store implements Node {
  address: Address
  dbId: ID
  id: ID!
  lastSyncAt: DateTime
  name: String!
  note: String
  phoneNumber: String
  posConfiguration: PosConfiguration
  storeChain: StoreChain
}

# A  C-Store Chain
type StoreChain implements Node {
  dbId: ID
  id: ID!
  name: String!
  stores(
    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the elements in the list that come after the specified global ID.
    after: String

    # Returns the last _n_ elements from the list.
    last: Int

    # Returns the elements in the list that come before the specified global ID.
    before: String
  ): StoreConnection
}

# The connection type for Store.
type StoreConnection {
  # A list of edges.
  edges: [StoreEdge]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type StoreEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: Store
}

# A  user
type User implements Node {
  address: Address
  email: String
  firstName: String
  id: ID!
  lastName: String
  phoneNumber: String
  role: Role
  store: Store
  username: String!
}

# A  authenticated user context
type Viewer {
  ReportsPeriod: [ReportsPeriod]
  me: User
  report(id: ID!): Report
  reportStore(id: ID!): ReportStore
  reportStores(reportId: ID!): ReportStore
  reports(
    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the elements in the list that come after the specified global ID.
    after: String

    # Returns the last _n_ elements from the list.
    last: Int

    # Returns the elements in the list that come before the specified global ID.
    before: String
    beginAt: DateTime!
    endAt: DateTime!
    reportAccountType: ReportAccountType!
    reportAccountStatus: ReportAccountStatus
    posName: PosName
    reportStatus: ReportStatus
    reportStoreStatus: [ReportStoreStatus]
  ): ReportConnection
}
